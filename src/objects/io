struct Ray
{
    vec3 o;		// origin
    vec3 d;		// direction
};

struct Hit
{
    float t;	// solution to p=o+t*d
    vec3 n;		// normal
    Material m;	// material
};
const Hit noHit = Hit(1e10, vec3(0.), Material(vec3(-1.), -1.));

struct Plane
{
    float d;	// solution to dot(n,p)+d=0
    vec3 n;		// normal
    Material m;	// material
};

struct Sphere
{
	float r;	// radius
    vec3 p;		// center position
    Material m;	// material
};

struct Cone
{
  float cosa;	// half cone angle
    float h;	// height
    vec3 c;		// tip position
    vec3 v;		// axis
    Material m;	// material
};

Hit intersectPlane(Plane p, Ray r)
{
    float dotnd = dot(p.n, r.d);
    if (dotnd > 0.) return noHit;

    float t = -(dot(r.o, p.n) + p.d) / dotnd;
    return Hit(t, p.n, p.m);
}

Hit intersectSphere(Sphere s, Ray r)
{
	vec3 op = s.p - r.o;
    float b = dot(op, r.d);
    float det = b * b - dot(op, op) + s.r * s.r;
    if (det < 0.) return noHit;

    det = sqrt(det);
    float t = b - det;
    if (t < 0.) t = b + det;
    if (t < 0.) return noHit;

    return Hit(t, (r.o + t*r.d - s.p) / s.r, s.m);
}

Hit intersectCone(Cone s, Ray r)
{
    vec3 co = r.o - s.c;

    float a = dot(r.d,s.v)*dot(r.d,s.v) - s.cosa*s.cosa;
    float b = 2. * (dot(r.d,s.v)*dot(co,s.v) - dot(r.d,co)*s.cosa*s.cosa);
    float c = dot(co,s.v)*dot(co,s.v) - dot(co,co)*s.cosa*s.cosa;

    float det = b*b - 4.*a*c;
    if (det < 0.) return noHit;

    det = sqrt(det);
    float t1 = (-b - det) / (2. * a);
    float t2 = (-b + det) / (2. * a);

    // This is a bit messy; there ought to be a more elegant solution.
    float t = t1;
    if (t < 0. || t2 > 0. && t2 < t) t = t2;
    if (t < 0.) return noHit;
    
    vec3 cp = r.o + t*r.d - s.c;
    float h = dot(cp, s.v);
    if (h < 0. || h > s.h) return noHit;

    vec3 n = normalize(cp * dot(s.v, cp) / dot(cp, cp) - s.v);

    return Hit(t, n, s.m);
}
struct Cone
{
  float cosa;	// half cone angle
    float h;	// height
    vec3 c;		// tip position
    vec3 v;		// axis
    Material m;	// material
};

vec4 iCylinder( in vec3 ro, in vec3 rd, 
                in vec3 pa, in vec3 pb, in float ra ) // point a, point b, radius
{
    // center the cylinder, normalize axis
    vec3 cc = 0.5*(pa+pb);
    float ch = length(pb-pa);
    vec3 ca = (pb-pa)/ch;
    ch *= 0.5;

    vec3  oc = ro - cc;

    float card = dot(ca,rd);
    float caoc = dot(ca,oc);
    
    float a = 1.0 - card*card;
    float b = dot( oc, rd) - caoc*card;
    float c = dot( oc, oc) - caoc*caoc - ra*ra;
    float h = b*b - a*c;
    if( h<0.0 ) return vec4(-1.0);
    h = sqrt(h);
    float t1 = (-b-h)/a;
    //float t2 = (-b+h)/a; // exit point

    float y = caoc + t1*card;

    // body
    if( abs(y)<ch ) return vec4( t1, normalize( oc+t1*rd - ca*y ) );
    
    // caps
    float sy = sign(y);
    float tp = (sy*ch - caoc)/card;
    if( abs(b+a*tp)<h )
    {
        return vec4( tp, ca*sy );
    }

    return vec4(-1.0);
}
