void		cylinder_normale(t_cylinder *cylinder, t_ray *hit)
{
	double		m;
	t_vec3f		tmp;

	tmp = cylinder->axis;
	vec3f_mul_unit2(&tmp, hit->tnear);
	m = vec3f_dot(&hit->raydir, &tmp)
		+ vec3f_dot(&hit->distance, &cylinder->axis);
	tmp = cylinder->axis;
	vec3f_mul_unit2(&tmp, m);
	vec3f_sub2(&hit->nhit, &cylinder->position);
	vec3f_sub2(&hit->nhit, &tmp);
}


/* axis = cone->axis; */
	/* if (vec3f_dot(&cone->axis, &hit_cpy) < 0) */
	/* 		vec3f_negate(&axis); */
	/* dist_to_apex = length(&hit_cpy) / cos(cone->angle / 2); */
	/* vec3f_mul_unit2(&axis, dist_to_apex); */
	/* vec3f_add2(&axis, &cone->tip_position); */
	/* vec3f_sub2(&axis, &hit->phit); */
//	vec3f_cpy(&hit->nhit, );

void		cone_normale2(t_cone *cone, t_ray *hit)
{
	float		m;
	t_vec3f		tmp;

	tmp = cone->axis;
	vec3f_mul_unit2(&tmp, hit->tnear);
	m = vec3f_dot(&hit->raydir, &tmp) + vec3f_dot(&hit->distance, &cone->axis);
	tmp = cone->axis;
	vec3f_mul_unit2(&tmp, m);
	vec3f_mul_unit2(&tmp, cone->tan_angle2);
	vec3f_sub2(&hit->nhit, &cone->tip_position);
	vec3f_sub2(&hit->nhit, &tmp);
}


int			cone_intersect2(t_cone *cone, t_ray *hit, double *res)
{
	double	k;
	double	dir_axis;
	double	dist_axis;

	k = cone->tan_angle2;
	dir_axis = vec3f_dot(&hit->raydir, &cone->axis);
	dist_axis = vec3f_dot(&hit->distance, &cone->axis);
	return (resolve_quadratic((t_vec3f){
				vec3f_dot(&hit->raydir, &hit->raydir) - k * pow(dir_axis, 2),
					2 * (vec3f_dot(&hit->raydir, &hit->distance)
					- k * dir_axis * dist_axis),
					vec3f_dot(&hit->distance, &hit->distance)
					- k * pow(dist_axis, 2)
					}, res));
}


void		cone_normale(t_cone *cone, t_ray *hit)
{
	float	dist_to_apex;
	t_vec3f	axis;
	t_vec3f	hit_cpy;

	hit_cpy = hit->phit;
	vec3f_sub2(&hit_cpy, &cone->tip_position);
	dist_to_apex = length(&hit_cpy) / cos(cone->angle / 2);
	axis = cone->axis;
	vec3f_mul_unit2(&axis, dist_to_apex);
	vec3f_sub2(&axis, &hit->phit);
	vec3f_cpy(&hit->nhit, &axis);
}

void	del_object(void *c, size_t size)
{
	t_obj		*content;

	/* content = c; */
	/* if (content) */
	/*   { */
	/*     free(content->tag); */
	/*     content->tag = 0; */
	/*     //free(content->obj.sphere); */
	/*   } */
	/* free(content); */
	/* content = 0; */
}

/* void		cone_normale(t_cone *cone, t_ray *hit) */
/* { */
/*   t_vec3f	n; */
/*   t_vec3f	tmp; */

/*   vec3f_sub2(&hit->nhit, &cone->tip_position); */
/*   vec3f_mul_unit2(&hit->nhit, vec3f_dot(&cone->axis, &hit->nhit) / vec3f_dot(&hit->nhit, &hit->nhit)); */
/*   vec3f_sub2(&hit->nhit, &cone->axis); */
/* } */











def resoudre_4_degre():
    global A3,A2,A1,A0
#    global b,c,d,e
    # considérons l'équation générale du quatrième degré :
    #          a4 x^4 + a3 x^3 + a2 x^2 + a1 x + a0 = 0   (1)
    # entrée des coefficients a4 , a3 , a2 , a1 , a0
    a4,a3,a2,a1,a0 = float(entr4.get()),float(entr3.get()),float(entr2.get()),float(entr1.get()),float(entr0.get())
    # transformation de l'équation :
    #          x^4 + b x^3 + c x^2 + d x + e = 0   (2)
    # avec les coefficients :
    b ,c ,d ,e = a3/a4 ,a2/a4 ,a1/a4 ,a0/a4
    # après le changement de variable : x = X - b/4
    # l'équation (2) devient :
    #          X^4 + p X^2 + q X + r = 0   (3)
    # avec les coefficients :
    p ,q ,r = c-3./8*b**2 ,d-b*c/2+b**3/8 ,e-b*d/4+c*b**2/16-3./256*b**4
    # étudions l'expression suivante :
    #          X^4 + y X^2 + y^2/4
    # soit :
    #          ( X^2 + y/2 )^2 = -p X^2 - q X - r + y X^2 + y^2/4
    #          ( X^2 + y/2 )^2 = ( y - p ) X^2 - q X + y^2/4 - r
    # son second membre est un carré parfait si le discriminant  de l'équation du second degré en X est nul :
    #          q^2 - 4 (y - p ) ( y^2 /4 - r ) = 0
    #          y^3 -p y^2 - 4 r y + 4 p r - q^2 = 0
    # considérons maintenant l'équation suivante :
    #          A3 y^3 + A2 y^2 + A1 y + A0 = 0
    # avec les coefficients :
    A3 ,A2 ,A1 ,A0 = 1,-p ,-4*r ,4*p*r-q**2
    #  et recherchons une racine réelle y1 :
    resoudre_3_degre()
    if y1==p:
        X1,X2,X3,X4=sqrt(-p/2+1./2*sqrt(p**2-4*r)),sqrt(-p/2-1./2*sqrt(p**2-4*r)),-sqrt(-p/2+1./2*sqrt(p**2-4*r)),-sqrt(-p/2-1./2*sqrt(p**2-4*r))
    else:
        y0=y1
        #  Discriminant D12
        D12=-y0-p+2*q/sqrt(y0-p)
        #  Discriminant D34
        D34=-y0-p-2*q/sqrt(y0-p)
    # calcul des quatre racines complexes de l'équation : X1, X2, X3, X4
        X1,X2,X3,X4=1./2*(-sqrt(y0-p)+sqrt(D12)),1./2*(-sqrt(y0-p)-sqrt(D12)),1./2*(sqrt(y0-p)+sqrt(D34)),1./2*(sqrt(y0-p)-sqrt(D34))
    # calcul des quatre racines complexes de l'équation : x1, x2, x3, x4
    x1,x2,x3,x4=X1-b/4,X2-b/4,X3-b/4,X4-b/4
    # isolation des parties réelles et imaginaires des quatre racines x1, x2, x3, x4
    xr1,xi1=x1.real,x1.imag
    xr2,xi2=x2.real,x2.imag
    xr3,xi3=x3.real,x3.imag
    xr4,xi4=x4.real,x4.imag
    # affichage des parties réelles et imaginaires avec trois décimales
    x1,x2,x3,x4=complex(round(xr1,3),round(xi1,3)),complex(round(xr2,3),round(xi2,3)),complex(round(xr3,3),round(xi3,3)),complex(round(xr4,3),round(xi4,3))
    # affichage des quatre racines dans le plan complexe de la fenêtre
    can.coords(c1,L/2+50*xr1-R,L/2-50*xi1-R,L/2+50*xr1+R,L/2-50*xi1+R)
    can.coords(c2,L/2+50*xr2-R,L/2-50*xi2-R,L/2+50*xr2+R,L/2-50*xi2+R)
    can.coords(c3,L/2+50*xr3-R,L/2-50*xi3-R,L/2+50*xr3+R,L/2-50*xi3+R)
    can.coords(c4,L/2+50*xr4-R,L/2-50*xi4-R,L/2+50*xr4+R,L/2-50*xi4+R)
    # affichage de leur légende dans le plan complexe de la fenêtre
    can.coords(txt_x1,L/2+50*xr1+15,L/2-50*xi1)
    can.coords(txt_x2,L/2+50*xr2,L/2-50*xi2-15)
    can.coords(txt_x3,L/2+50*xr3,L/2-50*xi3+15)
    can.coords(txt_x4,L/2+50*xr4-15,L/2-50*xi4)

    txta.configure(text = "" + str(a4))
    txtb.configure(text = "" + str(a3))
    txtc.configure(text = "" + str(a2))
    txtd.configure(text = "" + str(a1))
    txte.configure(text = "" + str(a0))

    text_x1.configure(text = "" + str(x1))
    text_x2.configure(text = "" + str(x2))
    text_x3.configure(text = "" + str(x3))
    text_x4.configure(text = "" + str(x4))
#_________________________________________________________________________________________________________________________________________________________________________

def resoudre_3_degre():
    global y1,y2,y3
    # considérons l'équation générale du troisième degré :
    #          A3 y^3 + A2 y^2 + A1 y + A0 = 0   (1)
    # soit encore :
    #          A y^3 + B y^2 + C y + D = 0   (2)
    # avec :
    B,C,D=A2/A3,A1/A3,A0/A3
    #  après le changement de variable y = Y - B/3
    # et en posant :
    P,Q=C/3-B*B/9,B*B*B/27-B*C/6+D/2
    # l'équation (2) devient :
    #          Y^3 + 3PY + 2Q = 0
    # calcul du discriminant
    Discriminant=P**3+Q**2
    # calcul de s = (signe de Q) x sqrt(valeur absolue de P)
    if P<>0:s=Q/fabs(Q)*sqrt(fabs(P))
    # calcul des trois racines complexes de l'équation : Y1, Y2, Y3
    if P<0:
        if Discriminant<=0:
            f=acos(Q/(s**3))
            Y1=complex(-2*s*cos(f/3))
            Y2=complex(2*s*cos(60*pi/180-f/3))
            Y3=complex(2*s*cos(60*pi/180+f/3))
        if Discriminant>0:
            fc=acosh(Q/(s**3))
            Y1=complex(-2*s*cosh(fc/3))
            Y2=complex(s*cosh(fc/3),sqrt(3)*s*sinh(fc/3))
            Y3=complex(s*cosh(fc/3),-sqrt(3)*s*sinh(fc/3))
    if P>0:
        fs=asinh(Q/(s**3))
        Y1=complex(-2*s*sinh(fs/3))
        Y2=complex(s*sinh(fs/3),sqrt(3)*s*cosh(fs/3))
        Y3=complex(s*sinh(fs/3),-sqrt(3)*s*cosh(fs/3))
    if P==0:
        if Q>0:Y1=Y2=Y3=complex(pow(2*Q,1./3))
        if Q<0:Y1=Y2=Y3=complex(pow(-2*Q,1./3))
        if Q==0:Y1=Y2=Y3=complex(0)
    # calcul des trois racines complexes de l'équation : y1, y2, y3
    y1,y2,y3=Y1-A2/(3*A3),Y2-A2/(3*A3),Y3-A2/(3*A3)
